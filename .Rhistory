theme_bw()+labs(fill="Mentor Program")+xlab("Number of students mentored")+ylab("Frequency")+
ggtitle("Distribution of 45 unique mentors", "By number of times mentored")
p3 <- ggplot(data=DRP_Total_Stats, aes(x=as.numeric(mentor.year), fill= program))+geom_histogram(binwidth=1)+
theme_bw()+labs(fill="Mentor Program")+xlab("Year in Program")+ylab("Frequency")+
ggtitle("Distribution of 95 mentors", "By year in program")
p1+p2+p3+plot_layout(guides="collect")
library(readxl)
setwd("~/Dropbox/Spa-DRP-google")
DRP_Total_Stats <- read_excel("DRP Total Stats.xlsx")
library(tidyverse)
DRP_Total_Stats$Quarter <- ordered(DRP_Total_Stats$Quarter,
levels=c("Winter 2020", "Spring 2020","Fall 2020",
"Winter 2021", "Spring 2021","Autumn 2021",
"Winter 2022", "Spring 2022","Autumn 2022",
"Winter 2023", "Spring 2023","Autumn 2023"),
labels = c("Win '20", "Spr '20","Fall '20",
"Win '21", "Spr '21","Fall '21",
"Win '22", "Spr '22","Fall '22",
"Win '23", "Spr '23","Fall '23"))
names(DRP_Total_Stats)[3] <- "program"
names(DRP_Total_Stats)[2] <- "mentor"
names(DRP_Total_Stats)[4] <- "mentor.year"
DRP_Total_Stats$program[DRP_Total_Stats$program=="Stat Postoc"] <- "Stat Postdoc"
DRP_Total_Stats[DRP_Total_Stats$program=="Stat Postdoc",]
DRP_Total_Stats[DRP_Total_Stats$program=="Stat Postdoc",]$mentor.year
DRP_Total_Stats[DRP_Total_Stats$program=="Stat Postdoc",]$mentor.year <- c(1,2)
rlang::last_trace()
DRP_Total_Stats[DRP_Total_Stats$program=="Stat Postdoc",]$mentor.year[1] <- 1
DRP_Total_Stats[DRP_Total_Stats$program=="Stat Postdoc",]$mentor.year[2] <- 2
DRP_summary <- DRP_Total_Stats %>% group_by(mentor, program) %>% summarize(freq=n())
NROW(DRP_Total_Stats)
NROW(DRP_summary)
library(patchwork)
p1 <- ggplot(data=DRP_Total_Stats, aes(x=Quarter, fill = program))+geom_bar() +
theme_bw()+
theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1),
plot.subtitle = element_text(size=8))+
ylab("Number of Projects")+
ggtitle("Distribution of 95 total projects", "(Spring 2020 anomoly due to COVID)")+
labs(fill = "Mentor Program")
p2 <- ggplot(data=DRP_summary, aes(x=freq, fill= program))+geom_histogram(binwidth=1)+
theme_bw()+labs(fill="Mentor Program")+xlab("Number of students mentored")+ylab("Frequency")+
ggtitle("Distribution of 45 unique mentors", "By number of times mentored")
p3 <- ggplot(data=DRP_Total_Stats, aes(x=as.numeric(mentor.year), fill= program))+geom_histogram(binwidth=1)+
theme_bw()+labs(fill="Mentor Program")+xlab("Year in Program")+ylab("Frequency")+
ggtitle("Distribution of 95 mentors", "By year in program")
p1+p2+p3+plot_layout(guides="collect")
?ordered
DRP_Total_Stats$program <- ordered(DRP_Total_Stats$program,
levels=c( "Biostat PhD","Stat Postdoc",
"Stat MS","Stat PhD"))
DRP_summary <- DRP_Total_Stats %>% group_by(mentor, program) %>% summarize(freq=n())
NROW(DRP_Total_Stats)
NROW(DRP_summary)
library(patchwork)
p1 <- ggplot(data=DRP_Total_Stats, aes(x=Quarter, fill = program))+geom_bar() +
theme_bw()+
theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1),
plot.subtitle = element_text(size=8))+
ylab("Number of Projects")+
ggtitle("Distribution of 95 total projects", "(Spring 2020 anomoly due to COVID)")+
labs(fill = "Mentor Program")
p2 <- ggplot(data=DRP_summary, aes(x=freq, fill= program))+geom_histogram(binwidth=1)+
theme_bw()+labs(fill="Mentor Program")+xlab("Number of students mentored")+ylab("Frequency")+
ggtitle("Distribution of 45 unique mentors", "By number of times mentored")
p3 <- ggplot(data=DRP_Total_Stats, aes(x=as.numeric(mentor.year), fill= program))+geom_histogram(binwidth=1)+
theme_bw()+labs(fill="Mentor Program")+xlab("Year in Program")+ylab("Frequency")+
ggtitle("Distribution of 95 mentors", "By year in program")
p1+p2+p3+plot_layout(guides="collect")
p1+p2+p3+plot_layout(guides="collect") &
scale_fill_discrete("blues")
ggsave("drp.png")
setwd("/Users/aneufeld/countsplit")
devtools::check()
urlchecker::url_check()
devtools::build_readme()
devtools::build_readme()
rlang::last_trace()
devtools::check(remote = TRUE, manual = TRUE)
?devtools::document
?roxygen2::roxygenize
?countsplit
devtools::document()
devtools::check(remote = TRUE, manual = TRUE)
usethis::use_revdep()
devtools::check()
?devtools::check
devtools::check(cran=TRUE, manual=TRUE)
devtools::submit_cran()
setwd("/Users/aneufeld/countsplit.tutorials")
pkgdown::build_site(lazy=TRUE)
pkgdown::build_site(lazy=TRUE)
null.pvals <- runif(480, min=0, max=1)
alt.pvals <- runif(20, min=0, max=0.02)
null.pvals <- runif(480, min=0, max=1)
alt.pvals <- runif(20, min=0, max=0.02)
pvals <- c(null.pvals, alt.pvals)
head(pvals)
pvals <- c( alt.pvals, null.pvals)
qvals <- qvalue::qvalue(p)
pvals <- c( alt.pvals, null.pvals)
qvals <- qvalue::qvalue(pvals)
pvals
qvals
res <- qvalue::qvalue(pvals)
qvals <- res$qvalues
qvals
plot(qvals)
table(qvals < 0.05)
head(qvals)
table(pvals < 0.05)
res
res$pi0
res$pi0
480/500
?qvalues::qvalue
?qvalue::qvalue
qvalue::lfdr
pi0 <- res$pi0
x <- qnorm(pvals)
myd <- density(x, adjust = adj)
?density
pi0 <- res$pi0
x <- qnorm(pvals)
myd <- density(x, adjust = 1.5)
mys <- smooth.spline(x = myd$x, y = myd$y)
y <- predict(mys, x)$y
lfdr <- pi0 * dnorm(x)/y
480/500
lfdr
qvalue::lfdr
pi0 <- res$pi0
x <- qnorm(pvals)
myd <- density(x, adjust = 1.5)
mys <- smooth.spline(x = myd$x, y = myd$y)
y <- predict(mys, x)$y
lfdr <- pi0 * dnorm(x)/y
lfdr[lfdr > 1] <- 1
o <- order(p, decreasing = FALSE)
pi0 <- res$pi0
x <- qnorm(pvals)
myd <- density(x, adjust = 1.5)
mys <- smooth.spline(x = myd$x, y = myd$y)
y <- predict(mys, x)$y
lfdr <- pi0 * dnorm(x)/y
lfdr[lfdr > 1] <- 1
o <- order(pvals, decreasing = FALSE)
ro <- order(o)
lfdr <- cummax(lfdr[o])[ro]
all.equal(lfdr, qvals)
plot(all.equal(lfdr, qvals))
lfdr
head(lfdr)
qvals
lfdr
qvalue::lfdr
qvalues::qvalue
qvalue::qvalue
i <- m:1L
m <- length(pvals)
i <- m:1L
i
i <- m:1
o
i
class(i)
class(1:mL)
class(m:1L)
o <- order(pvals, decreasing = TRUE)
ro <- order(o)
o
ro
which.max(pvals)
?qvalue::qvalue
pmin(1, cummin(p[o] * m/i))
pmin(1, cummin(pvals[o] * m/i))
pvals[o]
ordered.ps <- p[o]
ordered.ps <- pvals[o]
ordered.ps
pmin(1, cummin(p[o] * m/i))
pmin(1, cummin(pvals[o] * m/i))
all.equal(my.qvals, qvals)
ordered.ps <- pvals[o]
thresholded.adjusted.ps <- pmin(1, cummin(pvals[o] * m/i))
back.in.order <- thresholded.adjusted.ps[ro]
my.qvals <- pi0*back.in.order
all.equal(my.qvals, qvals)
pvals <- c(runif(20, min=0, max=0.002), runif(480, min=0, max=1))
pvals
pvals <- c(runif(20, min=0, max=0.02), runif(480, min=0, max=1))
pvals
res <- qvalue::qvalue(pvals)
qvals <- res$qvalues
pi0 <- res$pi0
pi0
set.seed(1)
pvals <- c(runif(20, min=0, max=0.02), runif(480, min=0, max=1))
res <- qvalue::qvalue(pvals)
qvals <- res$qvalues
pi0 <- res$pi0
pi0
set.seed(1)
pvals <- c(runif(20, min=0, max=0.002), runif(480, min=0, max=1))
res <- qvalue::qvalue(pvals)
qvals <- res$qvalues
pi0 <- res$pi0
pi0
set.seed(1)
pvals <- c(runif(20, min=0, max=0.02), runif(480, min=0, max=1))
res <- qvalue::qvalue(pvals)
qvals <- res$qvalues
pi0 <- res$pi0
pi0
20/500
pi0.est
pi0est
qvalue::qvalue
sapply(seq(0.1,1,length.out=10), function(u) sum(pvals > u)/length(pvals))
pi0est
qvalue::pi0est
my.pi0.ests <- sapply(seq(0.1,1,length.out=10), function(u) mean(pvals > u)/(1-u))
my.pi0.ests
my.pi0.ests <- sapply(seq(0.1,0.95,by=0.05), function(u) mean(pvals > u)/(1-u))
my.pi0.ests
res$pi0.lambda
my.pi0.ests <- sapply(seq(0.1,0.95,by=0.05), function(u) mean(pvals > u)/(1-u))
spi0 <- smooth.spline(seq(0.1,0.95,by=0.05), log(pi0), df = 3)
spi0 <- smooth.spline(seq(0.1,0.95,by=0.05), log(pi0), df = 3)
my.pi0.ests <- sapply(seq(0.1,0.95,by=0.05), function(u) mean(pvals > u)/(1-u))
spi0 <- smooth.spline(seq(0.1,0.95,by=0.05), log(my.pi0.ests ), df = 3)
pi0Smooth <- exp(predict(spi0, x =seq(0.1,0.95,by=0.05))$y)
pi0Smooth
my.pi0 <- min(pi0Smooth[ll], 1)
length(pi0Smooth[ll])
length(pi0Smooth)
my.pi0 <- min(pi0Smooth[18], 1)
my.pi0
pi0
set.seed(1)
m <- 500
pvals <- c(runif(20, min=0, max=0.02), runif(m-20, min=0, max=1))
res <- qvalue::qvalue(pvals)
qvals <- res$qvalues
pi0 <- res$pi0
my.pi0.ests <- sapply(seq(0.1,0.95,by=0.05), function(u) mean(pvals > u)/(1-u))
spi0 <- smooth.spline(seq(0.1,0.95,by=0.05), log(my.pi0.ests ), df = 3)
pi0Smooth <- exp(predict(spi0, x =seq(0.1,0.95,by=0.05))$y)
my.pi0 <- min(pi0Smooth[18], 1)
##### Make sure I can reproduce and that I understand each step.
p_in <- qvals_out <- lfdr_out <- pvals
m <- length(pvals)
i <- m:1
### Element 1 is the index of the largest pval
### Element 500 is the index of the smallest pval.
o <- order(pvals, decreasing = TRUE)
### Element 1 tells us what index in o stores gene 1.
### Elemens 2 tells us what element in in o stores gene 2. Etc.
ro <- order(o)
ordered.ps <- pvals[o]
thresholded.adjusted.ps <- pmin(1, cummin(pvals[o] * m/i))
back.in.order <- thresholded.adjusted.ps[ro]
my.qvals <- pi0*back.in.order
all.equal(my.qvals, qvals)
set.seed(1)
m <- 500
pvals <- c(runif(20, min=0, max=0.02), runif(m-20, min=0, max=1))
res <- qvalue::qvalue(pvals)
qvals <- res$qvalues
pi0 <- res$pi0
my.pi0.ests <- sapply(seq(0.1,0.95,by=0.05), function(u) mean(pvals > u)/(1-u))
spi0 <- smooth.spline(seq(0.1,0.95,by=0.05), log(my.pi0.ests ), df = 3)
pi0Smooth <- exp(predict(spi0, x =seq(0.1,0.95,by=0.05))$y)
my.pi0 <- min(pi0Smooth[18], 1)
##### Make sure I can reproduce and that I understand each step.
### Element 1 is the index of the largest pval
### Element 500 is the index of the smallest pval.
o <- order(pvals, decreasing = TRUE)
### Element 1 tells us what index in o stores gene 1.
### Elemens 2 tells us what element in in o stores gene 2. Etc.
ro <- order(o)
ordered.ps <- pvals[o]
i <- m:1
thresholded.adjusted.ps <- pmin(1, cummin(pvals[o] * m/i))
back.in.order <- thresholded.adjusted.ps[ro]
my.qvals <- pi0*back.in.order
all.equal(my.qvals, qvals)
set.seed(17)
m <- 500
pvals <- c(runif(20, min=0, max=0.02), runif(m-20, min=0, max=1))
res <- qvalue::qvalue(pvals)
qvals <- res$qvalues
pi0 <- res$pi0
my.pi0.ests <- sapply(seq(0.1,0.95,by=0.05), function(u) mean(pvals > u)/(1-u))
spi0 <- smooth.spline(seq(0.1,0.95,by=0.05), log(my.pi0.ests ), df = 3)
pi0Smooth <- exp(predict(spi0, x =seq(0.1,0.95,by=0.05))$y)
my.pi0 <- min(pi0Smooth[18], 1)
##### Make sure I can reproduce and that I understand each step.
### Element 1 is the index of the largest pval
### Element 500 is the index of the smallest pval.
o <- order(pvals, decreasing = TRUE)
### Element 1 tells us what index in o stores gene 1.
### Elemens 2 tells us what element in in o stores gene 2. Etc.
ro <- order(o)
ordered.ps <- pvals[o]
i <- m:1
thresholded.adjusted.ps <- pmin(1, cummin(pvals[o] * m/i))
back.in.order <- thresholded.adjusted.ps[ro]
my.qvals <- pi0*back.in.order
all.equal(my.qvals, qvals)
set.seed(17)
m <- 500
pvals <- c(runif(20, min=0, max=0.02), runif(m-20, min=0, max=1))
res <- qvalue::qvalue(pvals)
qvals <- res$qvalues
pi0 <- res$pi0
my.pi0.ests <- sapply(seq(0.1,0.95,by=0.05), function(u) mean(pvals > u)/(1-u))
spi0 <- smooth.spline(seq(0.1,0.95,by=0.05), log(my.pi0.ests ), df = 3)
pi0Smooth <- exp(predict(spi0, x =seq(0.1,0.95,by=0.05))$y)
my.pi0 <- min(pi0Smooth[18], 1)
##### Make sure I can reproduce and that I understand each step.
### Element 1 is the index of the largest pval
### Element 500 is the index of the smallest pval.
o <- order(pvals, decreasing = TRUE)
### Element 1 tells us what index in o stores gene 1.
### Elemens 2 tells us what element in in o stores gene 2. Etc.
ro <- order(o)
ordered.ps <- pvals[o]
i <- m:1
thresholded.adjusted.ps <- pmin(1, cummin(pvals[o] * m/i))
back.in.order <- thresholded.adjusted.ps[ro]
my.qvals <- pi0*back.in.order
all.equal(my.qvals, qvals)
table(qvals < 0.05)
set.seed(0)
m <- 500
pvals <- c(runif(20, min=0, max=0.02), runif(m-20, min=0, max=1))
res <- qvalue::qvalue(pvals)
qvals <- res$qvalues
pi0 <- res$pi0
my.pi0.ests <- sapply(seq(0.1,0.95,by=0.05), function(u) mean(pvals > u)/(1-u))
spi0 <- smooth.spline(seq(0.1,0.95,by=0.05), log(my.pi0.ests ), df = 3)
pi0Smooth <- exp(predict(spi0, x =seq(0.1,0.95,by=0.05))$y)
my.pi0 <- min(pi0Smooth[18], 1)
##### Make sure I can reproduce and that I understand each step.
### Element 1 is the index of the largest pval
### Element 500 is the index of the smallest pval.
o <- order(pvals, decreasing = TRUE)
### Element 1 tells us what index in o stores gene 1.
### Elemens 2 tells us what element in in o stores gene 2. Etc.
ro <- order(o)
ordered.ps <- pvals[o]
i <- m:1
thresholded.adjusted.ps <- pmin(1, cummin(pvals[o] * m/i))
back.in.order <- thresholded.adjusted.ps[ro]
my.qvals <- pi0*back.in.order
all.equal(my.qvals, qvals)
table(qvals < 0.05)
pvals.short <- pvals[1:50]
qvals.short <- qvalue::qvalue(pvals.short)$qvalue
pvals.short <- pvals[1:50]
qvals.short <- qvalue::qvalue(pvals.short)$qvalue
pvals.short <- pvals[1:50]
qvals.short <- qvalue::qvalue(pvals.short, df.smooth=1)$qvalue
pvals.short
pvals.short <- pvals[1:80]
qvals.short <- qvalue::qvalue(pvals.short)$qvalue
pi0
pvals.short <- pvals[1:100]
qvals.short <- qvalue::qvalue(pvals.short)$qvalue
table(qvals.short < 0.05)
?cummin
ordered.ps*m/(m:i)
pmin(1, cummin(ordered.ps*m/(m:i)))
estimated.fdrs <- pmin(1, cummin(ordered.ps*m/(m:1)))
all.equal(ordered.ps*m/(m:1), cummin(ordered.ps*m/(m:1)))
plot(ordered.ps*m/(m:1), cummin(ordered.ps*m/(m:1)))
set.seed(0)
m <- 500
pvals <- c(runif(20, min=0, max=0.02), runif(m-20, min=0, max=1))
res <- qvalue::qvalue(pvals)
qvals <- res$qvalues
pi0 <- res$pi0
my.pi0.ests <- sapply(seq(0.1,0.95,by=0.05), function(u) mean(pvals > u)/(1-u))
spi0 <- smooth.spline(seq(0.1,0.95,by=0.05), log(my.pi0.ests ), df = 3)
pi0Smooth <- exp(predict(spi0, x =seq(0.1,0.95,by=0.05))$y)
my.pi0 <- min(pi0Smooth[18], 1)
##### Make sure I can reproduce and that I understand each step.
### Element 1 is the index of the largest pval
### Element 500 is the index of the smallest pval.
o <- order(pvals, decreasing = TRUE)
### Element 1 tells us what index in o stores gene 1.
### Elemens 2 tells us what element in in o stores gene 2. Etc.
ro <- order(o)
ordered.ps <- pvals[o]
estimated.fdrs <- pmin(1, cummin(pi0*ordered.ps*m/(m:1)))
my.qvals  <- estimated.fdrs[ro]
#thresholded.adjusted.ps <- pmin(1, cummin(ordered.ps * m/i))
#back.in.order <- thresholded.adjusted.ps[ro]
#my.qvals <- pi0*back.in.order
all.equal(my.qvals, qvals)
table(qvals < 0.05)
library(tidyverse)
set.seed(1)
n=200
p=2
lambda <- matrix(exp(2.5), nrow=n, ncol=p, byrow = TRUE)
clusters <- sample(1:3, size=n, replace=TRUE)
lambda[clusters==2,1] <-  exp(5)
lambda[clusters==3,2] <-  exp(0.1)
true.overdisps <- c(3,6)
X <- sapply(1:p, function(u) rnbinom(length(lambda[,u]), mu=lambda[,u], size= true.overdisps[u]))
ggplot(data=NULL, aes(x=X[,1]+1, y=X[,2]+1, col=as.factor(clusters)))+
geom_point()+
scale_x_log10()+
scale_y_log10()+
theme_bw()+
labs(col="True Cluster")+
xlab("Gene 1 (log scale)")+ ylab("Gene 2 (log scale)")
cluster.sse <- function(trainDat, testDat, clusters.est, eps.train) {
totSS <- 0
for (lab in unique(clusters.est)) {
if (sum(clusters.est==lab) > 1) {
clustdat.test <- testDat[clusters.est==lab,]
clustdat.train <- trainDat[clusters.est==lab,]
colmeansTrain <- apply(clustdat.train, 2, mean)
pred.means <- 1/eps.train*colmeansTrain
ss <- apply(1/(1-eps.train)*clustdat.test, 1,  function(u) sum((log(u+1)-log(pred.means+1))^2))
totSS <- totSS+sum(ss)
}
}
return(totSS)
}
set.seed(2)
naive.res <- rep(NA, 10)
for (k in 1:10) {
clusters.est <- kmeans(log(X+1), centers=k)$cluster
naive.res[k] <- cluster.sse(X,X,clusters.est, 0.5)
}
naive.res
naive.res.norm <- (naive.res - min(naive.res))/(max(naive.res)-min(naive.res))
ggplot(data=NULL)+
geom_pointline(aes(x=1:10, y=naive.res.norm, col="Naive"))+
theme_bw()+
ylab("Within-cluster SSE")+
xlab("Number of cluster (k)")+
geom_vline(aes(xintercept=3))+
labs(col="Method")+
scale_x_continuous(breaks=0:11)
set.seed(5)
poisSplit <- countsplit(X)
Xtrain.pois <- poisSplit[[1]]
library(countsplit)
library(tidyverse)
library(Matrix)
library(lemon)
library(tidyverse)
set.seed(1)
n=200
p=2
lambda <- matrix(exp(2.5), nrow=n, ncol=p, byrow = TRUE)
clusters <- sample(1:3, size=n, replace=TRUE)
lambda[clusters==2,1] <-  exp(5)
lambda[clusters==3,2] <-  exp(0.1)
true.overdisps <- c(3,6)
X <- sapply(1:p, function(u) rnbinom(length(lambda[,u]), mu=lambda[,u], size= true.overdisps[u]))
ggplot(data=NULL, aes(x=X[,1]+1, y=X[,2]+1, col=as.factor(clusters)))+
geom_point()+
scale_x_log10()+
scale_y_log10()+
theme_bw()+
labs(col="True Cluster")+
xlab("Gene 1 (log scale)")+ ylab("Gene 2 (log scale)")
cluster.sse <- function(trainDat, testDat, clusters.est, eps.train) {
totSS <- 0
for (lab in unique(clusters.est)) {
if (sum(clusters.est==lab) > 1) {
clustdat.test <- testDat[clusters.est==lab,]
clustdat.train <- trainDat[clusters.est==lab,]
colmeansTrain <- apply(clustdat.train, 2, mean)
pred.means <- 1/eps.train*colmeansTrain
ss <- apply(1/(1-eps.train)*clustdat.test, 1,  function(u) sum((log(u+1)-log(pred.means+1))^2))
totSS <- totSS+sum(ss)
}
}
return(totSS)
}
set.seed(2)
naive.res <- rep(NA, 10)
for (k in 1:10) {
clusters.est <- kmeans(log(X+1), centers=k)$cluster
naive.res[k] <- cluster.sse(X,X,clusters.est, 0.5)
}
naive.res
naive.res.norm <- (naive.res - min(naive.res))/(max(naive.res)-min(naive.res))
ggplot(data=NULL)+
geom_pointline(aes(x=1:10, y=naive.res.norm, col="Naive"))+
theme_bw()+
ylab("Within-cluster SSE")+
xlab("Number of cluster (k)")+
geom_vline(aes(xintercept=3))+
labs(col="Method")+
scale_x_continuous(breaks=0:11)
set.seed(5)
poisSplit <- countsplit(X)
Xtrain.pois <- poisSplit[[1]]
X
dim(X)
poisSplit <- countsplit(X)
estimated.clusters <- kmeans(log(Xtrain.known+1), 6)$cluster
setwd("/Users/aneufeld/countsplit.tutorials")
pkgdown::build_site(lazy=T)
