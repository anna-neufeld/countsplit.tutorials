<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>DRAFT: Stability-based evaluation of clusters using Seurat • countsplit.tutorials</title><!-- jquery --><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script><!-- Bootstrap --><link href="https://cdnjs.cloudflare.com/ajax/libs/bootswatch/3.4.0/flatly/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous"><script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin="anonymous"></script><!-- bootstrap-toc --><link rel="stylesheet" href="../bootstrap-toc.css"><script src="../bootstrap-toc.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous"><!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet"><script src="../pkgdown.js"></script><meta property="og:title" content="DRAFT: Stability-based evaluation of clusters using Seurat"><meta property="og:description" content="countsplit.tutorials"><!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]--></head><body data-spy="scroll" data-target="#toc">
    

    <div class="container template-article">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">countsplit.tutorials</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="">2.0</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav"><li>
  <a href="../articles/countsplit_tutorial.html">Differential expression tutorial</a>
</li>
<li>
  <a href="../articles/MSE_tutorial.html">Cross validation tutorial</a>
</li>
<li>
  <a href="../articles/seurat_tutorial.html">Seurat tutorial</a>
</li>
<li>
  <a href="../articles/scran_tutorial.html">Scran tutorial</a>
</li>
<li>
  <a href="../articles/monocle3_tutorial.html">Monocle3 tutorial</a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
      </ul><ul class="nav navbar-nav navbar-right"></ul></div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

      

      </header>





<div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1 data-toc-skip>DRAFT: Stability-based evaluation of clusters
using Seurat</h1>
            
      
      
      <div class="hidden name"><code>Seurat_stability_demonstration.Rmd</code></div>

    </div>

    
    
<p>We start by loading the necessary packages and installing the
<code>pbmc</code> data. Note that this is the dataset used in the Seurat
<a
href="https://satijalab.org/seurat/articles/pbmc3k_tutorial.html">clustering
tutorial</a>, but is also included in the
<code>countsplit.tutorials</code> package for convenience.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="co"># Packages </span></span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a><span class="fu">library</span>(Seurat)</span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a><span class="fu">library</span>(countsplit)</span>
<span id="cb1-4"><a href="#cb1-4" tabindex="-1"></a><span class="fu">library</span>(Matrix)</span>
<span id="cb1-5"><a href="#cb1-5" tabindex="-1"></a><span class="fu">library</span>(tidyverse)</span>
<span id="cb1-6"><a href="#cb1-6" tabindex="-1"></a><span class="fu">library</span>(patchwork)</span>
<span id="cb1-7"><a href="#cb1-7" tabindex="-1"></a><span class="fu">library</span>(sctransform)</span>
<span id="cb1-8"><a href="#cb1-8" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" tabindex="-1"></a><span class="co"># Load data and replace underscores with dashes in rownames (needed for Seurat)</span></span>
<span id="cb1-10"><a href="#cb1-10" tabindex="-1"></a><span class="fu">data</span>(pbmc.counts, <span class="at">package=</span><span class="st">&quot;countsplit.tutorials&quot;</span>)</span>
<span id="cb1-11"><a href="#cb1-11" tabindex="-1"></a><span class="fu">rownames</span>(pbmc.counts) <span class="ot">&lt;-</span> <span class="fu">gsub</span>(<span class="at">x =</span> <span class="fu">rownames</span>(pbmc.counts), <span class="at">pattern =</span> <span class="st">&quot;_&quot;</span>, <span class="at">replacement =</span> <span class="st">&quot;-&quot;</span>)</span></code></pre></div>
<div id="motivation" class="section level1">
<h1>Motivation</h1>
<p>After preprocessing, the Seurat <a
href="https://satijalab.org/seurat/articles/pbmc3k_tutorial.html">clustering
tutorial</a> applies Louvain clustering (as implemented in
<code>Seurat::FindClusters</code>) to identify cell types in the data.
The Louvain clustering algorithm has a resolution parameter that
determines the granularity of the clustering, with larger values leading
to greater numbers of clusters. The Seurat tutorial suggests that values
between 0.4-1.2 typically return good results for single-cell datasets
of around 3,000 cells (the size of the <code>pbmc</code>) dataset, but
they note that this optimal value can increase for larger datasets. In
the tutorial itself, they use 0.5 as the resolution parameter.</p>
<p>In this tutorial, our goal is to use count splitting to empirically
determine an appropriate resolution parameter.</p>
<p>Let’s start by looking at the clusters originally estimated in the
Seurat tutorial.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">1</span>)</span>
<span id="cb2-2"><a href="#cb2-2" tabindex="-1"></a>pbmc <span class="ot">&lt;-</span> <span class="fu">CreateSeuratObject</span>(<span class="at">counts =</span> pbmc.counts, <span class="at">min.cells =</span> <span class="dv">5</span>, <span class="at">min.features =</span> <span class="dv">200</span>)</span>
<span id="cb2-3"><a href="#cb2-3" tabindex="-1"></a>pbmc <span class="ot">&lt;-</span></span>
<span id="cb2-4"><a href="#cb2-4" tabindex="-1"></a>  pbmc <span class="sc">%&gt;%</span></span>
<span id="cb2-5"><a href="#cb2-5" tabindex="-1"></a>  <span class="fu">NormalizeData</span>(<span class="at">verbose=</span>F)  <span class="sc">%&gt;%</span></span>
<span id="cb2-6"><a href="#cb2-6" tabindex="-1"></a>  <span class="fu">FindVariableFeatures</span>(<span class="at">verbose=</span>F)  <span class="sc">%&gt;%</span></span>
<span id="cb2-7"><a href="#cb2-7" tabindex="-1"></a>  <span class="fu">ScaleData</span>(<span class="at">verbose=</span>F)  <span class="sc">%&gt;%</span></span>
<span id="cb2-8"><a href="#cb2-8" tabindex="-1"></a>  <span class="fu">RunPCA</span>(<span class="at">verbose=</span>F)  <span class="sc">%&gt;%</span></span>
<span id="cb2-9"><a href="#cb2-9" tabindex="-1"></a>  <span class="fu">FindNeighbors</span>(<span class="at">dims =</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">10</span>,<span class="at">verbose=</span>F)  <span class="sc">%&gt;%</span></span>
<span id="cb2-10"><a href="#cb2-10" tabindex="-1"></a>  <span class="fu">RunUMAP</span>(<span class="at">dims =</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">10</span>,<span class="at">verbose=</span>F) <span class="sc">%&gt;%</span></span>
<span id="cb2-11"><a href="#cb2-11" tabindex="-1"></a>  <span class="fu">FindClusters</span>(<span class="at">resolution=</span><span class="fl">0.5</span>, <span class="at">verbose=</span>F)</span>
<span id="cb2-12"><a href="#cb2-12" tabindex="-1"></a><span class="fu">DimPlot</span>(pbmc, <span class="at">reduction =</span> <span class="st">&quot;umap&quot;</span>)</span></code></pre></div>
<p><img src="Seurat_stability_demonstration_files/figure-html/unnamed-chunk-2-1.png" width="90%" />
While the UMAP reduction has identified three clearly separated groups
of cells, it is harder to tell if the subgroups of cells within the
larger clusters are necessary. For example, what happens if make the
same plot, but with a resolution parameter of 0.1 or 1.0?</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a>pbmc <span class="ot">&lt;-</span></span>
<span id="cb3-2"><a href="#cb3-2" tabindex="-1"></a>  pbmc <span class="sc">%&gt;%</span></span>
<span id="cb3-3"><a href="#cb3-3" tabindex="-1"></a>  <span class="fu">FindClusters</span>(<span class="at">resolution=</span><span class="fl">0.1</span>, <span class="at">verbose=</span>F) <span class="sc">%&gt;%</span></span>
<span id="cb3-4"><a href="#cb3-4" tabindex="-1"></a>  <span class="fu">FindClusters</span>(<span class="at">resolution=</span><span class="fl">1.0</span>, <span class="at">verbose=</span>F)</span>
<span id="cb3-5"><a href="#cb3-5" tabindex="-1"></a><span class="fu">DimPlot</span>(pbmc, <span class="at">reduction =</span> <span class="st">&quot;umap&quot;</span>, <span class="at">group.by =</span> <span class="fu">paste0</span>(<span class="st">&quot;RNA_snn_res.&quot;</span>, <span class="fu">c</span>(<span class="fl">0.1</span>,<span class="fl">1.0</span>)))</span></code></pre></div>
<p><img src="Seurat_stability_demonstration_files/figure-html/unnamed-chunk-3-1.png" width="90%" />
Based on this plot, there is no clear reason to think that the
resolution parameter of 0.5 is better or worse than 0.1 or 1.0. In the
remainder of this tutorial, we will show how count splitting can help us
choose a resolution parameter.</p>
</div>
<div id="using-count-splitting" class="section level1">
<h1>Using count splitting</h1>
<p>In our <a
href="https://anna-neufeld.github.io/countsplit.tutorials/articles/MSE_tutorial.html">introduction
to cluster evaluation tutorial</a>, we used count splitting to choose
the optimal number of clusters in a toy dataset. More specifically, we
used the following workflow.</p>
<ol style="list-style-type: decimal">
<li>Use <code>countsplit</code> to turn a single dataset <span
class="math inline">\(X\)</span> into a training set <span
class="math inline">\(X^{\mathrm{train}}\)</span> and a test set <span
class="math inline">\(X^{\mathrm{test}}\)</span>.</li>
<li>Estimate clusters using <span
class="math inline">\(X^{\mathrm{train}}\)</span>.</li>
<li>Compute the within-cluster mean-squared-error (or a similar loss
function) when the centers of these training-set clusters are used to
predict the expression levels in <span
class="math inline">\(X^{\mathrm{test}}\)</span>.</li>
</ol>
<p>This represents a “reconstruction-based” evaluation of clusters. We
want to know if the estimated cluster centers can get close to
summarizing all of the information in our entire dataset. While this
makes sense on toy datasets, it can get very complicated for real
scRNA-seq data. For starters, we do not necessarily expect that our cell
types will do a good job summarizing all of the variation in our
sequencing data; they are just one important piece of the puzzle.
Furthermore, it is not clear what loss function should be used in Step
3. Using the standard <code>Seurat</code> workflow, the clusters are
estimated not on the raw counts but rather on the logged and
size-factor-normalized counts, using only the features that were
determined to be “highly variable”. Whether the loss function is
computed using all of the features or only the highly variable features,
for example, can really impact the results. Finally, this
mean-squared-error is not particularly interpretable: how do we know
what is a mean squared error that is “good” vs. “bad”?</p>
<p>For all of these complicated reasons, in this tutorial we take a
different approach to evaluating our clusters. More specifically, we
take a “reproducibility-based” approach. The basic premise is that, if
we split our dataset <span class="math inline">\(X\)</span> into
independent <span class="math inline">\(X^{\mathrm{train}}\)</span> and
<span class="math inline">\(X^{\mathrm{test}}\)</span>, we want the
clusters estimated on <span
class="math inline">\(X^{\mathrm{train}}\)</span> to be reproducible on
<span class="math inline">\(X^{\mathrm{test}}\)</span>. The ``best”
number of clusters for an analysis is the maximum number of clusters
that achieves a specified threshold of reproducibility. This approach is
similar to existing validation procedures based on cluster stability
(<span class="citation">Lange et al. (2004)</span>) or “prediction
strength” (<span class="citation">Tibshirani and Walther
(2005)</span>).</p>
<p>Previous implementations of stability-based cluster evaluation have
relied on repeated subsampling of the observations in the dataset.
Stability can then only be assessed on observations that overlapped
between the multiple subsamples. The nice thing about count splitting is
that it lets us repeatedly cluster the exact same set of cells. This
makes it a natural fit for these metrics.</p>
<p>We also briefly note that scRNA-seq cell types are not typically
well-separated clusters, and sometimes truly are nested as main cell
types and cell subtypes. This makes this problem really hard. In this
document, we do not provide a perfect solution for the problem of
estimating the number of clusters. But we do try to provide advice on
how you might go about choosing the correct number of clusters in a
principled way.</p>
</div>
<div id="poisson-count-splitting" class="section level1">
<h1>Poisson count splitting</h1>
<p>We first demonstrate the idea using Poisson count splitting. At the
bottom of the document, we repeat the same process but with negative
binomial count splitting.</p>
<p>The first step is splitting the data into two identically distributed
folds. Note that we set <code>min.cells</code> and
<code>min.features</code> to <span class="math inline">\(0\)</span> to
turn off any automatic filtering. We want the rows and columns of the
training set and the testing set to be identical, so we cannot filter
them separately.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a>poissonSplit <span class="ot">&lt;-</span> <span class="fu">countsplit</span>(<span class="fu">t</span>(pbmc.counts))</span>
<span id="cb4-2"><a href="#cb4-2" tabindex="-1"></a>Xtrain <span class="ot">&lt;-</span> <span class="fu">t</span>(poissonSplit[[<span class="dv">1</span>]])</span>
<span id="cb4-3"><a href="#cb4-3" tabindex="-1"></a>Xtest <span class="ot">&lt;-</span> <span class="fu">t</span>(poissonSplit[[<span class="dv">2</span>]])</span>
<span id="cb4-4"><a href="#cb4-4" tabindex="-1"></a>pbmcTrain <span class="ot">&lt;-</span> <span class="fu">CreateSeuratObject</span>(<span class="at">counts =</span> Xtrain, <span class="at">min.cells =</span> <span class="dv">0</span>, <span class="at">min.features =</span> <span class="dv">0</span>)</span>
<span id="cb4-5"><a href="#cb4-5" tabindex="-1"></a>pbmcTest <span class="ot">&lt;-</span> <span class="fu">CreateSeuratObject</span>(<span class="at">counts=</span>Xtest, <span class="at">min.cells=</span><span class="dv">0</span>, <span class="at">min.features=</span><span class="dv">0</span>)</span></code></pre></div>
<p>The next step is to perform our preferred normalization pipeline on
each dataset separately. Note that we filter both datasets to include
the same rows and columns as the full dataset from above. This gets rid
of genes and cells that had very little total expression.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a>pbmcTrain <span class="ot">&lt;-</span></span>
<span id="cb5-2"><a href="#cb5-2" tabindex="-1"></a>  pbmcTrain[<span class="fu">rownames</span>(pbmc), <span class="fu">colnames</span>(pbmc)]  <span class="sc">%&gt;%</span></span>
<span id="cb5-3"><a href="#cb5-3" tabindex="-1"></a>  <span class="fu">NormalizeData</span>(<span class="at">verbose=</span>F) <span class="sc">%&gt;%</span></span>
<span id="cb5-4"><a href="#cb5-4" tabindex="-1"></a>  <span class="fu">FindVariableFeatures</span>(<span class="at">verbose=</span>F) <span class="sc">%&gt;%</span></span>
<span id="cb5-5"><a href="#cb5-5" tabindex="-1"></a>  <span class="fu">ScaleData</span>(<span class="at">verbose=</span>F) <span class="sc">%&gt;%</span></span>
<span id="cb5-6"><a href="#cb5-6" tabindex="-1"></a>  <span class="fu">RunPCA</span>(<span class="at">verbose=</span>F) <span class="sc">%&gt;%</span></span>
<span id="cb5-7"><a href="#cb5-7" tabindex="-1"></a>  <span class="fu">FindNeighbors</span>(<span class="at">dims =</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">10</span>, <span class="at">verbose=</span>F) <span class="sc">%&gt;%</span></span>
<span id="cb5-8"><a href="#cb5-8" tabindex="-1"></a>  <span class="fu">RunUMAP</span>(<span class="at">dims =</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">10</span>, <span class="at">verbose=</span>F)</span></code></pre></div>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a>pbmcTest <span class="ot">&lt;-</span> pbmcTest[<span class="fu">rownames</span>(pbmc), <span class="fu">colnames</span>(pbmc)] <span class="sc">%&gt;%</span></span>
<span id="cb6-2"><a href="#cb6-2" tabindex="-1"></a>  <span class="fu">NormalizeData</span>(<span class="at">verbose=</span>F) <span class="sc">%&gt;%</span></span>
<span id="cb6-3"><a href="#cb6-3" tabindex="-1"></a>  <span class="fu">FindVariableFeatures</span>(<span class="at">verbose=</span>F) <span class="sc">%&gt;%</span></span>
<span id="cb6-4"><a href="#cb6-4" tabindex="-1"></a>  <span class="fu">ScaleData</span>(<span class="at">verbose=</span>F) <span class="sc">%&gt;%</span></span>
<span id="cb6-5"><a href="#cb6-5" tabindex="-1"></a>  <span class="fu">RunPCA</span>(<span class="at">verbose=</span>F) <span class="sc">%&gt;%</span></span>
<span id="cb6-6"><a href="#cb6-6" tabindex="-1"></a>  <span class="fu">FindNeighbors</span>(<span class="at">dims =</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">10</span>, <span class="at">verbose=</span>F) <span class="sc">%&gt;%</span></span>
<span id="cb6-7"><a href="#cb6-7" tabindex="-1"></a>  <span class="fu">RunUMAP</span>(<span class="at">dims =</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">10</span>, <span class="at">verbose=</span>F)</span></code></pre></div>
<p>Now consider what happens if we cluster each dataset separately using
a resolution parameter of 0.1, verses with a resolution parameter of
2.0.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a>pbmcTrain <span class="ot">&lt;-</span></span>
<span id="cb7-2"><a href="#cb7-2" tabindex="-1"></a>  pbmcTrain <span class="sc">%&gt;%</span></span>
<span id="cb7-3"><a href="#cb7-3" tabindex="-1"></a>  <span class="fu">FindClusters</span>(<span class="at">resolution=</span><span class="fl">0.1</span>, <span class="at">verbose=</span>F) <span class="sc">%&gt;%</span></span>
<span id="cb7-4"><a href="#cb7-4" tabindex="-1"></a>  <span class="fu">FindClusters</span>(<span class="at">resolution=</span><span class="fl">2.0</span>, <span class="at">verbose=</span>F)</span>
<span id="cb7-5"><a href="#cb7-5" tabindex="-1"></a>pbmcTest <span class="ot">&lt;-</span></span>
<span id="cb7-6"><a href="#cb7-6" tabindex="-1"></a>  pbmcTest <span class="sc">%&gt;%</span></span>
<span id="cb7-7"><a href="#cb7-7" tabindex="-1"></a>  <span class="fu">FindClusters</span>(<span class="at">resolution=</span><span class="fl">0.1</span>, <span class="at">verbose=</span>F) <span class="sc">%&gt;%</span></span>
<span id="cb7-8"><a href="#cb7-8" tabindex="-1"></a>  <span class="fu">FindClusters</span>(<span class="at">resolution=</span><span class="fl">2.0</span>, <span class="at">verbose=</span>F)</span></code></pre></div>
<p>Note that the results of each clustering got stored in the metadata
of the relevant object, with the name <code>RNA_snn_res.0.1</code> and
<code>RNA_snn_res.2</code>. This is useful for us.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" tabindex="-1"></a><span class="fu">head</span>(pbmcTrain<span class="sc">@</span>meta.data)</span></code></pre></div>
<pre><code>##                     orig.ident nCount_RNA nFeature_RNA RNA_snn_res.0.1
## AAACATACAACCAC-1 SeuratProject       1192          482               0
## AAACATTGAGCTAC-1 SeuratProject       2471          830               3
## AAACATTGATCAGC-1 SeuratProject       1554          693               0
## AAACCGTGCTTCCG-1 SeuratProject       1305          633               1
## AAACCGTGTATGCG-1 SeuratProject        490          303               2
## AAACGCACTGGTAC-1 SeuratProject       1089          492               0
##                  seurat_clusters RNA_snn_res.2
## AAACATACAACCAC-1               6             6
## AAACATTGAGCTAC-1               1             1
## AAACATTGATCAGC-1               0             0
## AAACCGTGCTTCCG-1              12            12
## AAACCGTGTATGCG-1              10            10
## AAACGCACTGGTAC-1               0             0</code></pre>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" tabindex="-1"></a><span class="fu">head</span>(pbmcTest<span class="sc">@</span>meta.data)</span></code></pre></div>
<pre><code>##                     orig.ident nCount_RNA nFeature_RNA RNA_snn_res.0.1
## AAACATACAACCAC-1 SeuratProject       1227          471               0
## AAACATTGAGCTAC-1 SeuratProject       2430          808               3
## AAACATTGATCAGC-1 SeuratProject       1591          701               0
## AAACCGTGCTTCCG-1 SeuratProject       1332          580               1
## AAACCGTGTATGCG-1 SeuratProject        490          289               2
## AAACGCACTGGTAC-1 SeuratProject       1074          457               0
##                  seurat_clusters RNA_snn_res.2
## AAACATACAACCAC-1               9             9
## AAACATTGAGCTAC-1               0             0
## AAACATTGATCAGC-1               2             2
## AAACCGTGCTTCCG-1               6             6
## AAACCGTGTATGCG-1               8             8
## AAACGCACTGGTAC-1              10            10</code></pre>
<p>I would like to visualize the two sets of clusterings in the same
low-dimensional space. To do this, we will plot the cells in the
training set UMAP space, colored with each potential clustering. To
easily make this plot, we add the test set clusters to the training set
meta data with the name <code>testRNA_snn_res</code>.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" tabindex="-1"></a>pbmcTrain<span class="sc">@</span>meta.data[[<span class="st">&quot;testRNA_snn_res.0.1&quot;</span>]] <span class="ot">&lt;-</span> pbmcTest<span class="sc">@</span>meta.data[[<span class="st">&quot;RNA_snn_res.0.1&quot;</span>]]</span>
<span id="cb12-2"><a href="#cb12-2" tabindex="-1"></a>pbmcTrain<span class="sc">@</span>meta.data[[<span class="st">&quot;testRNA_snn_res.2&quot;</span>]] <span class="ot">&lt;-</span> pbmcTest<span class="sc">@</span>meta.data[[<span class="st">&quot;RNA_snn_res.2&quot;</span>]]</span></code></pre></div>
<p>Now that the test set clusters are stored in the training set meta
data, we can easily compare the following four plots.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" tabindex="-1"></a><span class="fu">DimPlot</span>(pbmcTrain, <span class="at">reduction =</span> <span class="st">&quot;umap&quot;</span>, <span class="at">group.by =</span> <span class="fu">c</span>(<span class="st">&quot;RNA_snn_res.0.1&quot;</span>, <span class="st">&quot;testRNA_snn_res.0.1&quot;</span>,</span>
<span id="cb13-2"><a href="#cb13-2" tabindex="-1"></a>                                                    <span class="st">&quot;RNA_snn_res.2&quot;</span>, <span class="st">&quot;testRNA_snn_res.2&quot;</span>))</span></code></pre></div>
<p><img src="Seurat_stability_demonstration_files/figure-html/unnamed-chunk-10-1.png" width="90%" /></p>
<p>The takeaway from this plot is as follows. When we use a resolution
parameter of 0.1, the clusters estimated on the training set are almost
perfectly preserved on the test set. The only differences are that the
tiny little cluster that is part of the green cluster in the training
set becomes its own cluster in the test set, and that there is some
fuzziness on the border of the blue/pink clusters. On the other hand,
with a resolution parameter of 2, we can see that many of the clusters
estimated on the training set are not preserved on the test set. This
suggests that a parameter of 2 leads to <em>too many</em> clusters-
because many are not reproducible.</p>
<p>If we estimate clusters for a wide range of resolution parameters,
how do we quantify this degree of stability? One unfortunate issue with
stability metrics is that the results are always the most stable with a
small number of clusters; thus, the stability likely will not be
minimized at the true number of clusters. However, we can come up with
an interpretable metric for stability, and then select the largest
number of clusters that achieves an acceptable threshold for this
metric.</p>
<p>In this document, we use the metric from <span
class="citation">Tibshirani and Walther (2005)</span>. For every
training set cluster, we compute the proportion of observation pairs in
that cluster that are also assigned to the same cluster in the test set.
We then take the minimum of this quantity over all training set
clusters. The intuition is as follows. Suppose that there was some
training set cluster where, in the test set, the observations got
jumbled and all belonged to different clusters. Then this training set
cluster probably should not have existed; i.e. there should have been at
least one fewer cluster estimated on the training set. We implement this
metric here:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" tabindex="-1"></a>stabilityLoss <span class="ot">&lt;-</span> <span class="cf">function</span>(trainingClusters, testClusters) {</span>
<span id="cb14-2"><a href="#cb14-2" tabindex="-1"></a>  uniqueTrain <span class="ot">&lt;-</span> <span class="fu">unique</span>(trainingClusters) </span>
<span id="cb14-3"><a href="#cb14-3" tabindex="-1"></a>  minScore <span class="ot">&lt;-</span> <span class="cn">Inf</span></span>
<span id="cb14-4"><a href="#cb14-4" tabindex="-1"></a>  <span class="cf">for</span> (clust <span class="cf">in</span> uniqueTrain) {</span>
<span id="cb14-5"><a href="#cb14-5" tabindex="-1"></a>    obs1 <span class="ot">&lt;-</span> <span class="fu">which</span>(trainingClusters<span class="sc">==</span>clust)</span>
<span id="cb14-6"><a href="#cb14-6" tabindex="-1"></a>    testAssgt <span class="ot">&lt;-</span> testClusters[obs1]</span>
<span id="cb14-7"><a href="#cb14-7" tabindex="-1"></a>    total <span class="ot">&lt;-</span> <span class="fu">length</span>(testAssgt) <span class="sc">*</span> (<span class="fu">length</span>(testAssgt) <span class="sc">-</span> <span class="dv">1</span>)</span>
<span id="cb14-8"><a href="#cb14-8" tabindex="-1"></a>    match <span class="ot">&lt;-</span> <span class="fu">sum</span>(<span class="fu">table</span>(testAssgt) <span class="sc">*</span> (<span class="fu">table</span>(testAssgt) <span class="sc">-</span> <span class="dv">1</span>)) </span>
<span id="cb14-9"><a href="#cb14-9" tabindex="-1"></a>    <span class="cf">if</span> (match<span class="sc">/</span>total <span class="sc">&lt;</span> minScore) {</span>
<span id="cb14-10"><a href="#cb14-10" tabindex="-1"></a>     minScore <span class="ot">&lt;-</span> match<span class="sc">/</span>total</span>
<span id="cb14-11"><a href="#cb14-11" tabindex="-1"></a>    }</span>
<span id="cb14-12"><a href="#cb14-12" tabindex="-1"></a>  }</span>
<span id="cb14-13"><a href="#cb14-13" tabindex="-1"></a>  <span class="fu">return</span>(minScore)</span>
<span id="cb14-14"><a href="#cb14-14" tabindex="-1"></a>}</span></code></pre></div>
<p>We note that many similar metrics could be proposed, but for now we
stick with this one. Another option would be Jaccquard similarity, used
in <span class="citation">Tang et al. (2021)</span>.</p>
<p>We now cluster our training and test data for several resolution
parameters and compute this metric.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" tabindex="-1"></a>resRange <span class="ot">&lt;-</span> <span class="fu">seq</span>(<span class="fl">0.1</span>, <span class="dv">4</span>, <span class="at">by =</span> <span class="fl">0.1</span>)</span>
<span id="cb15-2"><a href="#cb15-2" tabindex="-1"></a>results.poisson <span class="ot">&lt;-</span> <span class="fu">rep</span>(<span class="cn">NA</span>, <span class="fu">length</span>(resRange))</span>
<span id="cb15-3"><a href="#cb15-3" tabindex="-1"></a></span>
<span id="cb15-4"><a href="#cb15-4" tabindex="-1"></a><span class="cf">for</span> (k <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="fu">length</span>(resRange)) {</span>
<span id="cb15-5"><a href="#cb15-5" tabindex="-1"></a>  pbmcTrain <span class="ot">&lt;-</span> <span class="fu">FindClusters</span>(pbmcTrain, <span class="at">resolution =</span> resRange[k], <span class="at">verbose=</span><span class="cn">FALSE</span>)</span>
<span id="cb15-6"><a href="#cb15-6" tabindex="-1"></a>  pbmcTest <span class="ot">&lt;-</span> <span class="fu">FindClusters</span>(pbmcTest, <span class="at">resolution =</span> resRange[k], <span class="at">verbose=</span><span class="cn">FALSE</span>)</span>
<span id="cb15-7"><a href="#cb15-7" tabindex="-1"></a>  </span>
<span id="cb15-8"><a href="#cb15-8" tabindex="-1"></a>  <span class="do">### The most recent clustering is always stored in &quot;seurat_clusters&quot;. </span></span>
<span id="cb15-9"><a href="#cb15-9" tabindex="-1"></a>  clusters.train <span class="ot">&lt;-</span>  pbmcTrain<span class="sc">@</span>meta.data[[<span class="st">&quot;seurat_clusters&quot;</span>]]</span>
<span id="cb15-10"><a href="#cb15-10" tabindex="-1"></a>  clusters.test <span class="ot">&lt;-</span>  pbmcTest<span class="sc">@</span>meta.data[[<span class="st">&quot;seurat_clusters&quot;</span>]]</span>
<span id="cb15-11"><a href="#cb15-11" tabindex="-1"></a>  results.poisson[k] <span class="ot">&lt;-</span> <span class="fu">stabilityLoss</span>(clusters.train, clusters.test)</span>
<span id="cb15-12"><a href="#cb15-12" tabindex="-1"></a>}</span></code></pre></div>
<p>We can now plot this metric. Recall that large values are preferable.
We want to pick the largest value of the resolution parameter that
achieves an acceptable value of this metric. <span
class="citation">Tibshirani and Walther (2005)</span> suggested a cutoff
of 0.8, but that was for well-separated clusters. As these clusters are
not well-separated, we might be willing to go as low as 0.5.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" tabindex="-1"></a><span class="fu">ggplot</span>(<span class="at">data=</span><span class="cn">NULL</span>, <span class="fu">aes</span>(<span class="at">x=</span>resRange, <span class="at">y=</span>results.poisson))<span class="sc">+</span><span class="fu">geom_point</span>()<span class="sc">+</span><span class="fu">geom_line</span>()<span class="sc">+</span><span class="fu">xlab</span>(<span class="st">&quot;Resolution Parameter&quot;</span>)<span class="sc">+</span><span class="fu">ylab</span>(<span class="st">&quot;Stability of Clustering&quot;</span>)<span class="sc">+</span><span class="fu">ggtitle</span>(<span class="st">&quot;Poisson Count Splitting&quot;</span>)<span class="sc">+</span><span class="fu">geom_hline</span>(<span class="at">yintercept=</span><span class="fl">0.5</span>, <span class="at">col=</span><span class="st">&quot;red&quot;</span>)</span></code></pre></div>
<p><img src="Seurat_stability_demonstration_files/figure-html/unnamed-chunk-13-1.png" width="90%" /></p>
<p>Based on this plot, when we use a resolution parameter of 0.7, the
least reproducible cluster estimated on the training set is still 60%
intact on the test set. For a resolution parameter of 1.5. that number
drops to 20%. This is interpretable evidence that 1.5 is too large of a
resolution parameter for this data, and that values larger than 0.7 or
so should not be used.</p>
<p>Note that if we want to view UMAP plots of the training set or test
set for any particular resolution parameter, we should do so as
follows:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" tabindex="-1"></a>pbmcTrain<span class="sc">@</span>meta.data[[<span class="fu">paste0</span>(<span class="st">&quot;testRNA_snn_res.0.7&quot;</span>)]] <span class="ot">&lt;-</span> pbmcTest<span class="sc">@</span>meta.data[[<span class="fu">paste0</span>(<span class="st">&quot;RNA_snn_res.0.7&quot;</span>)]]</span>
<span id="cb17-2"><a href="#cb17-2" tabindex="-1"></a><span class="fu">DimPlot</span>(pbmcTrain, <span class="at">reduction =</span> <span class="st">&quot;umap&quot;</span>, <span class="at">group.by =</span> <span class="fu">c</span>(<span class="st">&quot;RNA_snn_res.0.7&quot;</span>, <span class="st">&quot;testRNA_snn_res.0.7&quot;</span>))</span></code></pre></div>
<p><img src="Seurat_stability_demonstration_files/figure-html/unnamed-chunk-14-1.png" width="90%" /></p>
<p>Note that, we could try repeating this procedure over multiple random
splits to be even more sure of our findings. We do this below, for 15
random splits of the data.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1" tabindex="-1"></a>nSplits <span class="ot">&lt;-</span> <span class="dv">15</span></span>
<span id="cb18-2"><a href="#cb18-2" tabindex="-1"></a><span class="co">#resNames &lt;- paste0(&quot;RNA_snn_res.&quot;, resRange)</span></span>
<span id="cb18-3"><a href="#cb18-3" tabindex="-1"></a>results.poisson.multi <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="cn">NA</span>, <span class="at">nrow=</span>nSplits, <span class="at">ncol=</span><span class="fu">length</span>(resRange))</span>
<span id="cb18-4"><a href="#cb18-4" tabindex="-1"></a></span>
<span id="cb18-5"><a href="#cb18-5" tabindex="-1"></a><span class="cf">for</span> (split <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>nSplits) {</span>
<span id="cb18-6"><a href="#cb18-6" tabindex="-1"></a>  poissonSplit <span class="ot">&lt;-</span> <span class="fu">countsplit</span>(<span class="fu">t</span>(pbmc.counts))</span>
<span id="cb18-7"><a href="#cb18-7" tabindex="-1"></a>  Xtrain <span class="ot">&lt;-</span> <span class="fu">t</span>(poissonSplit[[<span class="dv">1</span>]])</span>
<span id="cb18-8"><a href="#cb18-8" tabindex="-1"></a>  Xtest <span class="ot">&lt;-</span> <span class="fu">t</span>(poissonSplit[[<span class="dv">2</span>]])</span>
<span id="cb18-9"><a href="#cb18-9" tabindex="-1"></a>  pbmcTrain <span class="ot">&lt;-</span> <span class="fu">CreateSeuratObject</span>(<span class="at">counts =</span> Xtrain, <span class="at">min.cells =</span> <span class="dv">0</span>, <span class="at">min.features =</span> <span class="dv">0</span>)</span>
<span id="cb18-10"><a href="#cb18-10" tabindex="-1"></a>  pbmcTest <span class="ot">&lt;-</span> <span class="fu">CreateSeuratObject</span>(<span class="at">counts=</span>Xtest, <span class="at">min.cells=</span><span class="dv">0</span>, <span class="at">min.features=</span><span class="dv">0</span>)</span>
<span id="cb18-11"><a href="#cb18-11" tabindex="-1"></a></span>
<span id="cb18-12"><a href="#cb18-12" tabindex="-1"></a>  pbmcTrain <span class="ot">&lt;-</span></span>
<span id="cb18-13"><a href="#cb18-13" tabindex="-1"></a>    pbmcTrain[<span class="fu">rownames</span>(pbmc), <span class="fu">colnames</span>(pbmc)]  <span class="sc">%&gt;%</span></span>
<span id="cb18-14"><a href="#cb18-14" tabindex="-1"></a>    <span class="fu">NormalizeData</span>(<span class="at">verbose=</span>F) <span class="sc">%&gt;%</span></span>
<span id="cb18-15"><a href="#cb18-15" tabindex="-1"></a>    <span class="fu">FindVariableFeatures</span>(<span class="at">verbose=</span>F) <span class="sc">%&gt;%</span></span>
<span id="cb18-16"><a href="#cb18-16" tabindex="-1"></a>    <span class="fu">ScaleData</span>(<span class="at">verbose=</span>F) <span class="sc">%&gt;%</span></span>
<span id="cb18-17"><a href="#cb18-17" tabindex="-1"></a>    <span class="fu">RunPCA</span>(<span class="at">verbose=</span>F) <span class="sc">%&gt;%</span></span>
<span id="cb18-18"><a href="#cb18-18" tabindex="-1"></a>    <span class="fu">FindNeighbors</span>(<span class="at">dims =</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">10</span>, <span class="at">verbose=</span>F) <span class="sc">%&gt;%</span></span>
<span id="cb18-19"><a href="#cb18-19" tabindex="-1"></a>    <span class="fu">RunUMAP</span>(<span class="at">dims =</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">10</span>, <span class="at">verbose=</span>F)</span>
<span id="cb18-20"><a href="#cb18-20" tabindex="-1"></a>  </span>
<span id="cb18-21"><a href="#cb18-21" tabindex="-1"></a>  pbmcTest <span class="ot">&lt;-</span> pbmcTest[<span class="fu">rownames</span>(pbmc), <span class="fu">colnames</span>(pbmc)] <span class="sc">%&gt;%</span></span>
<span id="cb18-22"><a href="#cb18-22" tabindex="-1"></a>    <span class="fu">NormalizeData</span>(<span class="at">verbose=</span>F) <span class="sc">%&gt;%</span></span>
<span id="cb18-23"><a href="#cb18-23" tabindex="-1"></a>    <span class="fu">FindVariableFeatures</span>(<span class="at">verbose=</span>F) <span class="sc">%&gt;%</span></span>
<span id="cb18-24"><a href="#cb18-24" tabindex="-1"></a>    <span class="fu">ScaleData</span>(<span class="at">verbose=</span>F) <span class="sc">%&gt;%</span></span>
<span id="cb18-25"><a href="#cb18-25" tabindex="-1"></a>    <span class="fu">RunPCA</span>(<span class="at">verbose=</span>F) <span class="sc">%&gt;%</span></span>
<span id="cb18-26"><a href="#cb18-26" tabindex="-1"></a>    <span class="fu">FindNeighbors</span>(<span class="at">dims =</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">10</span>, <span class="at">verbose=</span>F) <span class="sc">%&gt;%</span></span>
<span id="cb18-27"><a href="#cb18-27" tabindex="-1"></a>    <span class="fu">RunUMAP</span>(<span class="at">dims =</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">10</span>, <span class="at">verbose=</span>F)</span>
<span id="cb18-28"><a href="#cb18-28" tabindex="-1"></a>  </span>
<span id="cb18-29"><a href="#cb18-29" tabindex="-1"></a>  <span class="cf">for</span> (k <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="fu">length</span>(resRange)) {</span>
<span id="cb18-30"><a href="#cb18-30" tabindex="-1"></a>    pbmcTrain <span class="ot">&lt;-</span> <span class="fu">FindClusters</span>(pbmcTrain, <span class="at">resolution =</span> resRange[k], <span class="at">verbose=</span><span class="cn">FALSE</span>)</span>
<span id="cb18-31"><a href="#cb18-31" tabindex="-1"></a>    pbmcTest <span class="ot">&lt;-</span> <span class="fu">FindClusters</span>(pbmcTest, <span class="at">resolution =</span> resRange[k], <span class="at">verbose=</span><span class="cn">FALSE</span>)</span>
<span id="cb18-32"><a href="#cb18-32" tabindex="-1"></a>    </span>
<span id="cb18-33"><a href="#cb18-33" tabindex="-1"></a>    <span class="do">### This always stores the most recent run. </span></span>
<span id="cb18-34"><a href="#cb18-34" tabindex="-1"></a>    clusters.train <span class="ot">&lt;-</span>  pbmcTrain<span class="sc">@</span>meta.data[[<span class="st">&quot;seurat_clusters&quot;</span>]]</span>
<span id="cb18-35"><a href="#cb18-35" tabindex="-1"></a>    clusters.test <span class="ot">&lt;-</span>  pbmcTest<span class="sc">@</span>meta.data[[<span class="st">&quot;seurat_clusters&quot;</span>]]</span>
<span id="cb18-36"><a href="#cb18-36" tabindex="-1"></a>    results.poisson.multi[split, k] <span class="ot">&lt;-</span> <span class="fu">stabilityLoss</span>(clusters.train, clusters.test)</span>
<span id="cb18-37"><a href="#cb18-37" tabindex="-1"></a>  }</span>
<span id="cb18-38"><a href="#cb18-38" tabindex="-1"></a>}</span></code></pre></div>
<div class="sourceCode" id="cb19"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" tabindex="-1"></a><span class="fu">ggplot</span>(<span class="at">data=</span><span class="cn">NULL</span>, <span class="fu">aes</span>(<span class="at">x=</span>resRange, <span class="at">y=</span><span class="fu">colMeans</span>(results.poisson.multi)))<span class="sc">+</span><span class="fu">geom_point</span>()<span class="sc">+</span><span class="fu">geom_line</span>()<span class="sc">+</span><span class="fu">xlab</span>(<span class="st">&quot;Resolution Parameter&quot;</span>)<span class="sc">+</span><span class="fu">ylab</span>(<span class="st">&quot;Average stability of clustering&quot;</span>)<span class="sc">+</span><span class="fu">ggtitle</span>(<span class="st">&quot;Multiple splits: Poisson&quot;</span>)<span class="sc">+</span></span>
<span id="cb19-2"><a href="#cb19-2" tabindex="-1"></a>  <span class="fu">geom_hline</span>(<span class="at">yintercept=</span><span class="fl">0.5</span>, <span class="at">col=</span><span class="st">&quot;red&quot;</span>)</span></code></pre></div>
<p><img src="Seurat_stability_demonstration_files/figure-html/unnamed-chunk-16-1.png" width="90%" /></p>
</div>
<div id="negative-binomial-count-splitting" class="section level1">
<h1>Negative binomial count splitting</h1>
<p>It will be interesting to see if we get different results using
negative binomial splitting. If anything, we should see less stability
for a given resolution parameter, since with Poisson splitting we may
have observed artificially high stability driven by correlation between
the training set and the test set.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1" tabindex="-1"></a>overdisps <span class="ot">&lt;-</span> <span class="fu">rep</span>(<span class="cn">Inf</span>, <span class="fu">nrow</span>(pbmc.counts))</span>
<span id="cb20-2"><a href="#cb20-2" tabindex="-1"></a><span class="fu">names</span>(overdisps) <span class="ot">&lt;-</span> <span class="fu">rownames</span>(pbmc.counts)</span>
<span id="cb20-3"><a href="#cb20-3" tabindex="-1"></a>sctransform_fit <span class="ot">&lt;-</span> sctransform<span class="sc">::</span><span class="fu">vst</span>(pbmc.counts, <span class="at">verbosity=</span><span class="dv">0</span>, <span class="at">residual_type =</span> <span class="st">&quot;none&quot;</span>, <span class="at">min_cells =</span> <span class="dv">10</span>, <span class="at">n_genes=</span><span class="dv">5000</span>)</span>
<span id="cb20-4"><a href="#cb20-4" tabindex="-1"></a>overdisps[<span class="fu">rownames</span>(sctransform_fit<span class="sc">$</span>model_pars_fit)] <span class="ot">&lt;-</span> sctransform_fit<span class="sc">$</span>model_pars_fit[,<span class="st">&quot;theta&quot;</span>]</span>
<span id="cb20-5"><a href="#cb20-5" tabindex="-1"></a></span>
<span id="cb20-6"><a href="#cb20-6" tabindex="-1"></a>nbSplit <span class="ot">&lt;-</span> <span class="fu">countsplit</span>(<span class="fu">t</span>(pbmc.counts))</span>
<span id="cb20-7"><a href="#cb20-7" tabindex="-1"></a>Xtrain <span class="ot">&lt;-</span> <span class="fu">t</span>(nbSplit[[<span class="dv">1</span>]])</span>
<span id="cb20-8"><a href="#cb20-8" tabindex="-1"></a>Xtest <span class="ot">&lt;-</span> <span class="fu">t</span>(nbSplit[[<span class="dv">2</span>]])</span>
<span id="cb20-9"><a href="#cb20-9" tabindex="-1"></a>pbmcTrainNB <span class="ot">&lt;-</span> <span class="fu">CreateSeuratObject</span>(<span class="at">counts =</span> Xtrain, <span class="at">min.cells =</span> <span class="dv">0</span>, <span class="at">min.features =</span> <span class="dv">0</span>)</span>
<span id="cb20-10"><a href="#cb20-10" tabindex="-1"></a>pbmcTestNB <span class="ot">&lt;-</span> <span class="fu">CreateSeuratObject</span>(<span class="at">counts=</span>Xtest, <span class="at">min.cells=</span><span class="dv">0</span>, <span class="at">min.features=</span><span class="dv">0</span>)</span>
<span id="cb20-11"><a href="#cb20-11" tabindex="-1"></a></span>
<span id="cb20-12"><a href="#cb20-12" tabindex="-1"></a>pbmcTrainNB <span class="ot">&lt;-</span></span>
<span id="cb20-13"><a href="#cb20-13" tabindex="-1"></a>  pbmcTrainNB[<span class="fu">rownames</span>(pbmc), <span class="fu">colnames</span>(pbmc)]  <span class="sc">%&gt;%</span></span>
<span id="cb20-14"><a href="#cb20-14" tabindex="-1"></a>  <span class="fu">NormalizeData</span>(<span class="at">verbose=</span>F) <span class="sc">%&gt;%</span></span>
<span id="cb20-15"><a href="#cb20-15" tabindex="-1"></a>  <span class="fu">FindVariableFeatures</span>(<span class="at">verbose=</span>F) <span class="sc">%&gt;%</span></span>
<span id="cb20-16"><a href="#cb20-16" tabindex="-1"></a>  <span class="fu">ScaleData</span>(<span class="at">verbose=</span>F) <span class="sc">%&gt;%</span></span>
<span id="cb20-17"><a href="#cb20-17" tabindex="-1"></a>  <span class="fu">RunPCA</span>(<span class="at">verbose=</span>F) <span class="sc">%&gt;%</span></span>
<span id="cb20-18"><a href="#cb20-18" tabindex="-1"></a>  <span class="fu">FindNeighbors</span>(<span class="at">dims =</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">10</span>, <span class="at">verbose=</span>F) <span class="sc">%&gt;%</span></span>
<span id="cb20-19"><a href="#cb20-19" tabindex="-1"></a>  <span class="fu">RunUMAP</span>(<span class="at">dims =</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">10</span>, <span class="at">verbose=</span>F)</span>
<span id="cb20-20"><a href="#cb20-20" tabindex="-1"></a></span>
<span id="cb20-21"><a href="#cb20-21" tabindex="-1"></a>pbmcTestNB <span class="ot">&lt;-</span> pbmcTestNB[<span class="fu">rownames</span>(pbmc), <span class="fu">colnames</span>(pbmc)] <span class="sc">%&gt;%</span></span>
<span id="cb20-22"><a href="#cb20-22" tabindex="-1"></a>  <span class="fu">NormalizeData</span>(<span class="at">verbose=</span>F) <span class="sc">%&gt;%</span></span>
<span id="cb20-23"><a href="#cb20-23" tabindex="-1"></a>  <span class="fu">FindVariableFeatures</span>(<span class="at">verbose=</span>F) <span class="sc">%&gt;%</span></span>
<span id="cb20-24"><a href="#cb20-24" tabindex="-1"></a>  <span class="fu">ScaleData</span>(<span class="at">verbose=</span>F) <span class="sc">%&gt;%</span></span>
<span id="cb20-25"><a href="#cb20-25" tabindex="-1"></a>  <span class="fu">RunPCA</span>(<span class="at">verbose=</span>F) <span class="sc">%&gt;%</span></span>
<span id="cb20-26"><a href="#cb20-26" tabindex="-1"></a>  <span class="fu">FindNeighbors</span>(<span class="at">dims =</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">10</span>, <span class="at">verbose=</span>F) <span class="sc">%&gt;%</span></span>
<span id="cb20-27"><a href="#cb20-27" tabindex="-1"></a>  <span class="fu">RunUMAP</span>(<span class="at">dims =</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">10</span>, <span class="at">verbose=</span>F)</span>
<span id="cb20-28"><a href="#cb20-28" tabindex="-1"></a></span>
<span id="cb20-29"><a href="#cb20-29" tabindex="-1"></a>results.nb <span class="ot">&lt;-</span> <span class="fu">rep</span>(<span class="cn">NA</span>, <span class="fu">length</span>(resRange))</span>
<span id="cb20-30"><a href="#cb20-30" tabindex="-1"></a></span>
<span id="cb20-31"><a href="#cb20-31" tabindex="-1"></a><span class="cf">for</span> (k <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="fu">length</span>(resRange)) {</span>
<span id="cb20-32"><a href="#cb20-32" tabindex="-1"></a>  pbmcTrain <span class="ot">&lt;-</span> <span class="fu">FindClusters</span>(pbmcTrainNB, <span class="at">resolution =</span> resRange[k], <span class="at">verbose=</span><span class="cn">FALSE</span>)</span>
<span id="cb20-33"><a href="#cb20-33" tabindex="-1"></a>  pbmcTest <span class="ot">&lt;-</span> <span class="fu">FindClusters</span>(pbmcTestNB, <span class="at">resolution =</span> resRange[k], <span class="at">verbose=</span><span class="cn">FALSE</span>)</span>
<span id="cb20-34"><a href="#cb20-34" tabindex="-1"></a>  </span>
<span id="cb20-35"><a href="#cb20-35" tabindex="-1"></a>  <span class="do">### The most recent clustering is always stored in &quot;seurat_clusters&quot;. </span></span>
<span id="cb20-36"><a href="#cb20-36" tabindex="-1"></a>  clusters.train <span class="ot">&lt;-</span>  pbmcTrain<span class="sc">@</span>meta.data[[<span class="st">&quot;seurat_clusters&quot;</span>]]</span>
<span id="cb20-37"><a href="#cb20-37" tabindex="-1"></a>  clusters.test <span class="ot">&lt;-</span>  pbmcTest<span class="sc">@</span>meta.data[[<span class="st">&quot;seurat_clusters&quot;</span>]]</span>
<span id="cb20-38"><a href="#cb20-38" tabindex="-1"></a>  results.nb[k] <span class="ot">&lt;-</span> <span class="fu">stabilityLoss</span>(clusters.train, clusters.test)</span>
<span id="cb20-39"><a href="#cb20-39" tabindex="-1"></a>}</span>
<span id="cb20-40"><a href="#cb20-40" tabindex="-1"></a></span>
<span id="cb20-41"><a href="#cb20-41" tabindex="-1"></a></span>
<span id="cb20-42"><a href="#cb20-42" tabindex="-1"></a><span class="fu">ggplot</span>(<span class="at">data=</span><span class="cn">NULL</span>)<span class="sc">+</span></span>
<span id="cb20-43"><a href="#cb20-43" tabindex="-1"></a>  <span class="fu">geom_line</span>(<span class="fu">aes</span>(<span class="at">x=</span>resRange, <span class="at">y=</span>results.nb, <span class="at">col=</span><span class="st">&quot;Negative Binomial&quot;</span>))<span class="sc">+</span></span>
<span id="cb20-44"><a href="#cb20-44" tabindex="-1"></a>  <span class="fu">geom_line</span>(<span class="fu">aes</span>(<span class="at">x=</span>resRange, <span class="at">y=</span>results.poisson, <span class="at">col=</span><span class="st">&quot;Poisson&quot;</span>))<span class="sc">+</span></span>
<span id="cb20-45"><a href="#cb20-45" tabindex="-1"></a>  <span class="fu">ylim</span>(<span class="dv">0</span>,<span class="dv">1</span>)<span class="sc">+</span><span class="fu">ggtitle</span>(<span class="st">&quot;Adding Negative Binomial Count Splitting&quot;</span>)<span class="sc">+</span><span class="fu">xlab</span>(<span class="st">&quot;Resolution Parameter&quot;</span>)<span class="sc">+</span><span class="fu">ylab</span>(<span class="st">&quot;Stability&quot;</span>)<span class="sc">+</span><span class="fu">theme_bw</span>()<span class="sc">+</span><span class="fu">geom_hline</span>(<span class="at">yintercept=</span><span class="fl">0.5</span>, <span class="at">col=</span><span class="st">&quot;red&quot;</span>)</span></code></pre></div>
<p><img src="Seurat_stability_demonstration_files/figure-html/unnamed-chunk-17-1.png" width="90%" />
We can see that the curves produced by negative binomial count splitting
and Poisson count splitting yield almost identical results here.</p>
</div>
<div id="summary" class="section level1">
<h1>Summary</h1>
<p>These stability metrics allow us to see that, if we choose a
resolution parameter greater than 1, some of the clusters that we
estimate are not reproducible. While this does not help us determine
exactly the “correct” number of clusters, it is a fairly interpretable
way to guide out choice. More work in this area is coming soon!</p>
</div>
<div id="citations" class="section level1 unnumbered">
<h1 class="unnumbered">Citations</h1>
<div id="refs" class="references csl-bib-body hanging-indent">
<div id="ref-lange2004stability" class="csl-entry">
Lange, Tilman, Volker Roth, Mikio L Braun, and Joachim M Buhmann. 2004.
<span>“Stability-Based Validation of Clustering Solutions.”</span>
<em>Neural Computation</em> 16 (6): 1299–1323.
</div>
<div id="ref-tang2021evaluating" class="csl-entry">
Tang, Ming, Yasin Kaymaz, Brandon L Logeman, Stephen Eichhorn,
Zhengzheng S Liang, Catherine Dulac, and Timothy B Sackton. 2021.
<span>“Evaluating Single-Cell Cluster Stability Using the Jaccard
Similarity Index.”</span> <em>Bioinformatics</em> 37 (15): 2212–14.
</div>
<div id="ref-tibshirani2005cluster" class="csl-entry">
Tibshirani, Robert, and Guenther Walther. 2005. <span>“Cluster
Validation by Prediction Strength.”</span> <em>Journal of Computational
and Graphical Statistics</em> 14 (3): 511–28.
</div>
</div>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="pkgdown-sidebar">

        <nav id="toc" data-toggle="toc"><h2 data-toc-skip>Contents</h2>
    </nav>
      </div>

</div>



      <footer><div class="copyright">
  <p></p><p>Developed by Anna Neufeld.</p>
</div>

<div class="pkgdown">
  <p></p><p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.0.7.</p>
</div>

      </footer></div>

  


  

  </body></html>
